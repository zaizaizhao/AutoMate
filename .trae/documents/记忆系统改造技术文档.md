# 记忆系统改造技术文档

## 1. 现有记忆系统分析

### 1.1 PostgreSQLStore 功能分析

**当前功能：**
- 基于 LangGraph BaseStore 接口实现
- 支持基本的 CRUD 操作（get, put, delete, list）
- 使用 namespace 和 key 的组合进行数据索引
- 支持过期时间管理
- 数据以 JSON 格式存储

**局限性：**
- 缺少复杂查询能力（如按条件筛选、排序、分页）
- 不支持批量操作
- 缺少事务支持
- 没有针对特定业务场景的优化查询方法
- batch 方法未实现

### 1.2 SharedMemoryManager 功能分析

**当前功能：**
- 提供统一的记忆管理接口
- 支持命名空间管理
- 集成 PostgresSaver 和 PostgreSQLStore
- 支持过期时间和元数据管理
- 提供清理过期记忆的功能

**局限性：**
- 缺少针对特定数据类型的专用方法
- 没有批量操作支持
- 缺少复杂查询和统计功能
- 没有针对任务计划和进度管理的专门接口

## 2. 新需求分析

### 2.1 TaskPlanedForTest 存储需求

```typescript
export interface TaskPlanedForTest {
  batchIndex: number;
  taskId: string;
  toolName: string;
  description: string;
  parameters: Record<string, any> | string;
  complexity: 'low' | 'medium' | 'high';
  isRequiredValidateByDatabase: boolean;
}
```

**存储需求：**
- 需要支持按 batchIndex 批量查询
- 需要支持按 taskId 精确查询
- 需要支持按 toolName 和 complexity 筛选
- 需要支持批量插入和更新操作
- 需要支持事务操作确保数据一致性

### 2.2 PlanProgress 进度管理需求

```typescript
export interface PlanProgress {
  planId: string;
  totalBatches: number;
  completedBatches: number;
  failedBatches: number;
  currentBatchIndex: number;
  overallSuccessRate: number;
  lastUpdated: Date;
}
```

**管理需求：**
- 需要支持实时更新进度信息
- 需要支持按 planId 快速查询
- 需要支持进度统计和计算
- 需要支持历史进度记录查询

## 3. 数据库表结构设计

### 3.1 task_plans 表设计

```sql
CREATE TABLE task_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    plan_id VARCHAR(255) NOT NULL,
    batch_index INTEGER NOT NULL,
    task_id VARCHAR(255) NOT NULL UNIQUE,
    tool_name VARCHAR(255) NOT NULL,
    description TEXT,
    parameters JSONB,
    complexity VARCHAR(20) CHECK (complexity IN ('low', 'medium', 'high')),
    is_required_validate_by_database BOOLEAN DEFAULT false,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'running', 'completed', 'failed')),
    result JSONB,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- 创建索引
CREATE INDEX idx_task_plans_plan_id ON task_plans(plan_id);
CREATE INDEX idx_task_plans_batch_index ON task_plans(plan_id, batch_index);
CREATE INDEX idx_task_plans_task_id ON task_plans(task_id);
CREATE INDEX idx_task_plans_tool_name ON task_plans(tool_name);
CREATE INDEX idx_task_plans_status ON task_plans(status);
CREATE INDEX idx_task_plans_complexity ON task_plans(complexity);
```

### 3.2 plan_progress 表设计

```sql
CREATE TABLE plan_progress (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    plan_id VARCHAR(255) NOT NULL UNIQUE,
    total_batches INTEGER NOT NULL DEFAULT 0,
    completed_batches INTEGER NOT NULL DEFAULT 0,
    failed_batches INTEGER NOT NULL DEFAULT 0,
    current_batch_index INTEGER NOT NULL DEFAULT 0,
    overall_success_rate DECIMAL(5,2) DEFAULT 0.00,
    status VARCHAR(20) DEFAULT 'planning' CHECK (status IN ('planning', 'running', 'completed', 'failed', 'paused')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- 创建索引
CREATE INDEX idx_plan_progress_plan_id ON plan_progress(plan_id);
CREATE INDEX idx_plan_progress_status ON plan_progress(status);
CREATE INDEX idx_plan_progress_last_updated ON plan_progress(last_updated DESC);
```

### 3.3 更新现有 memory_store 表

```sql
-- 为现有表添加新字段以支持更好的查询
ALTER TABLE memory_store ADD COLUMN IF NOT EXISTS data_type VARCHAR(50);
ALTER TABLE memory_store ADD COLUMN IF NOT EXISTS tags JSONB;

-- 创建新索引
CREATE INDEX IF NOT EXISTS idx_memory_store_data_type ON memory_store(data_type);
CREATE INDEX IF NOT EXISTS idx_memory_store_tags ON memory_store USING GIN(tags);
```

## 4. SharedMemoryManager 扩展方案

### 4.1 新增接口定义

```typescript
// 扩展 SharedMemoryManager 类
export class SharedMemoryManager {
  // ... 现有方法 ...

  // TaskPlan 相关方法
  async saveTaskPlan(planId: string, task: TaskPlanedForTest): Promise<void>;
  async saveTaskPlans(planId: string, tasks: TaskPlanedForTest[]): Promise<void>;
  async getTaskPlan(taskId: string): Promise<TaskPlanedForTest | null>;
  async getTaskPlansByBatch(planId: string, batchIndex: number): Promise<TaskPlanedForTest[]>;
  async getTaskPlansByPlan(planId: string): Promise<TaskPlanedForTest[]>;
  async updateTaskPlanStatus(taskId: string, status: string, result?: any, errorMessage?: string): Promise<void>;
  async deleteTaskPlan(taskId: string): Promise<boolean>;
  async deleteTaskPlansByPlan(planId: string): Promise<number>;

  // PlanProgress 相关方法
  async savePlanProgress(progress: PlanProgress): Promise<void>;
  async getPlanProgress(planId: string): Promise<PlanProgress | null>;
  async updatePlanProgress(planId: string, updates: Partial<PlanProgress>): Promise<void>;
  async incrementCompletedBatches(planId: string): Promise<void>;
  async incrementFailedBatches(planId: string): Promise<void>;
  async updateCurrentBatchIndex(planId: string, batchIndex: number): Promise<void>;
  async calculateSuccessRate(planId: string): Promise<number>;
  async getAllPlanProgress(status?: string): Promise<PlanProgress[]>;
  async deletePlanProgress(planId: string): Promise<boolean>;

  // 统计和查询方法
  async getTaskStatsByPlan(planId: string): Promise<{
    total: number;
    pending: number;
    running: number;
    completed: number;
    failed: number;
    byComplexity: Record<string, number>;
  }>;
  
  async getTaskStatsByBatch(planId: string, batchIndex: number): Promise<{
    total: number;
    completed: number;
    failed: number;
    successRate: number;
  }>;
}
```

### 4.2 实现示例

```typescript
// TaskPlan 相关方法实现
async saveTaskPlan(planId: string, task: TaskPlanedForTest): Promise<void> {
  const client = await this.pool.connect();
  try {
    await client.query(
      `INSERT INTO task_plans (
        plan_id, batch_index, task_id, tool_name, description, 
        parameters, complexity, is_required_validate_by_database
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (task_id) 
      DO UPDATE SET 
        batch_index = EXCLUDED.batch_index,
        tool_name = EXCLUDED.tool_name,
        description = EXCLUDED.description,
        parameters = EXCLUDED.parameters,
        complexity = EXCLUDED.complexity,
        is_required_validate_by_database = EXCLUDED.is_required_validate_by_database,
        updated_at = NOW()`,
      [
        planId,
        task.batchIndex,
        task.taskId,
        task.toolName,
        task.description,
        JSON.stringify(task.parameters),
        task.complexity,
        task.isRequiredValidateByDatabase
      ]
    );
  } finally {
    client.release();
  }
}

async saveTaskPlans(planId: string, tasks: TaskPlanedForTest[]): Promise<void> {
  const client = await this.pool.connect();
  try {
    await client.query('BEGIN');
    
    for (const task of tasks) {
      await this.saveTaskPlan(planId, task);
    }
    
    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

// PlanProgress 相关方法实现
async savePlanProgress(progress: PlanProgress): Promise<void> {
  const client = await this.pool.connect();
  try {
    await client.query(
      `INSERT INTO plan_progress (
        plan_id, total_batches, completed_batches, failed_batches,
        current_batch_index, overall_success_rate, last_updated
      ) VALUES ($1, $2, $3, $4, $5, $6, $7)
      ON CONFLICT (plan_id)
      DO UPDATE SET
        total_batches = EXCLUDED.total_batches,
        completed_batches = EXCLUDED.completed_batches,
        failed_batches = EXCLUDED.failed_batches,
        current_batch_index = EXCLUDED.current_batch_index,
        overall_success_rate = EXCLUDED.overall_success_rate,
        last_updated = EXCLUDED.last_updated`,
      [
        progress.planId,
        progress.totalBatches,
        progress.completedBatches,
        progress.failedBatches,
        progress.currentBatchIndex,
        progress.overallSuccessRate,
        progress.lastUpdated
      ]
    );
  } finally {
    client.release();
  }
}
```

## 5. PostgreSQLStore 改造方案

### 5.1 扩展 PostgreSQLStore 类

```typescript
export class PostgreSQLStore extends BaseStore {
  // ... 现有方法 ...

  // 实现 batch 方法
  async batch<Op extends Operation[]>(operations: Op): Promise<OperationResults<Op>> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      
      const results: any[] = [];
      
      for (const operation of operations) {
        switch (operation.type) {
          case 'get':
            results.push(await this.get(operation.namespace, operation.key));
            break;
          case 'put':
            await this.put(operation.namespace, operation.key, operation.value);
            results.push(undefined);
            break;
          case 'delete':
            await this.delete(operation.namespace, operation.key);
            results.push(undefined);
            break;
          default:
            throw new Error(`Unsupported operation type: ${(operation as any).type}`);
        }
      }
      
      await client.query('COMMIT');
      return results as OperationResults<Op>;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  // 新增复杂查询方法
  async search(
    namespace: string[],
    options: {
      keyPattern?: string;
      dataType?: string;
      tags?: Record<string, any>;
      limit?: number;
      offset?: number;
      orderBy?: 'updated_at' | 'key';
      orderDirection?: 'ASC' | 'DESC';
    } = {}
  ): Promise<Array<{ key: string; value: any; metadata?: any }>> {
    let query = `
      SELECT key, value, metadata, updated_at
      FROM memory_store
      WHERE namespace_path = $1
        AND (expires_at IS NULL OR expires_at > NOW())
    `;
    
    const params: any[] = [namespace];
    let paramIndex = 2;
    
    if (options.keyPattern) {
      query += ` AND key LIKE $${paramIndex}`;
      params.push(options.keyPattern);
      paramIndex++;
    }
    
    if (options.dataType) {
      query += ` AND data_type = $${paramIndex}`;
      params.push(options.dataType);
      paramIndex++;
    }
    
    if (options.tags) {
      query += ` AND tags @> $${paramIndex}`;
      params.push(JSON.stringify(options.tags));
      paramIndex++;
    }
    
    const orderBy = options.orderBy || 'updated_at';
    const orderDirection = options.orderDirection || 'DESC';
    query += ` ORDER BY ${orderBy} ${orderDirection}`;
    
    if (options.limit) {
      query += ` LIMIT $${paramIndex}`;
      params.push(options.limit);
      paramIndex++;
    }
    
    if (options.offset) {
      query += ` OFFSET $${paramIndex}`;
      params.push(options.offset);
    }
    
    const client = await this.pool.connect();
    try {
      const result = await client.query(query, params);
      
      return result.rows.map(row => ({
        key: row.key,
        value: JSON.parse(row.value),
        metadata: JSON.parse(row.metadata || '{}')
      }));
    } finally {
      client.release();
    }
  }

  // 批量操作方法
  async putMany(
    namespace: string[],
    items: Array<{ key: string; value: any; dataType?: string; tags?: Record<string, any> }>
  ): Promise<void> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      
      for (const item of items) {
        await client.query(
          `INSERT INTO memory_store (namespace_path, key, value, data_type, tags, updated_at)
           VALUES ($1, $2, $3, $4, $5, NOW())
           ON CONFLICT (namespace_path, key)
           DO UPDATE SET 
             value = EXCLUDED.value,
             data_type = EXCLUDED.data_type,
             tags = EXCLUDED.tags,
             updated_at = NOW()`,
          [
            namespace,
            item.key,
            JSON.stringify(item.value),
            item.dataType,
            JSON.stringify(item.tags || {})
          ]
        );
      }
      
      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}
```

## 6. 集成方案

### 6.1 PlanAgent 集成

```typescript
// PlanAgent 中的使用示例
export class PlanAgent extends BaseAgent {
  private memoryManager: SharedMemoryManager;

  async executePlan(threadId: string, tasks: TaskPlanedForTest[]): Promise<void> {
    // 1. 保存任务计划
    await this.memoryManager.saveTaskPlans(threadId, tasks);
    
    // 2. 初始化或更新进度
    const existingProgress = await this.memoryManager.getPlanProgress(threadId);
    if (!existingProgress) {
      const progress: PlanProgress = {
        planId: threadId,
        totalBatches: Math.max(...tasks.map(t => t.batchIndex)) + 1,
        completedBatches: 0,
        failedBatches: 0,
        currentBatchIndex: 0,
        overallSuccessRate: 0,
        lastUpdated: new Date()
      };
      await this.memoryManager.savePlanProgress(progress);
    }
    
    // 3. 按批次执行任务
    const batches = this.groupTasksByBatch(tasks);
    for (const [batchIndex, batchTasks] of batches) {
      await this.executeBatch(threadId, batchIndex, batchTasks);
    }
  }

  private async executeBatch(
    planId: string, 
    batchIndex: number, 
    tasks: TaskPlanedForTest[]
  ): Promise<void> {
    // 更新当前批次索引
    await this.memoryManager.updateCurrentBatchIndex(planId, batchIndex);
    
    // 执行批次中的任务（这里可以调用 TestAgent）
    let batchSuccess = true;
    
    for (const task of tasks) {
      try {
        // 更新任务状态为运行中
        await this.memoryManager.updateTaskPlanStatus(task.taskId, 'running');
        
        // 执行任务（调用 TestAgent 或其他执行逻辑）
        const result = await this.executeTask(task);
        
        // 更新任务状态为完成
        await this.memoryManager.updateTaskPlanStatus(task.taskId, 'completed', result);
      } catch (error) {
        // 更新任务状态为失败
        await this.memoryManager.updateTaskPlanStatus(
          task.taskId, 
          'failed', 
          null, 
          error.message
        );
        batchSuccess = false;
      }
    }
    
    // 更新批次完成状态
    if (batchSuccess) {
      await this.memoryManager.incrementCompletedBatches(planId);
    } else {
      await this.memoryManager.incrementFailedBatches(planId);
    }
    
    // 重新计算成功率
    const successRate = await this.memoryManager.calculateSuccessRate(planId);
    await this.memoryManager.updatePlanProgress(planId, {
      overallSuccessRate: successRate,
      lastUpdated: new Date()
    });
  }
}
```

### 6.2 TestAgent 集成

```typescript
// TestAgent 中的使用示例
export class TestAgent extends BaseAgent {
  private memoryManager: SharedMemoryManager;

  async executeTask(taskId: string): Promise<any> {
    // 1. 获取任务详情
    const task = await this.memoryManager.getTaskPlan(taskId);
    if (!task) {
      throw new Error(`Task not found: ${taskId}`);
    }
    
    // 2. 执行任务逻辑
    const result = await this.performTask(task);
    
    // 3. 如果需要数据库验证
    if (task.isRequiredValidateByDatabase) {
      await this.validateResult(result);
    }
    
    return result;
  }

  async getBatchTasks(planId: string, batchIndex: number): Promise<TaskPlanedForTest[]> {
    return await this.memoryManager.getTaskPlansByBatch(planId, batchIndex);
  }

  async getTaskStats(planId: string): Promise<any> {
    return await this.memoryManager.getTaskStatsByPlan(planId);
  }
}
```

## 7. 实施步骤和迁移策略

### 7.1 第一阶段：数据库表创建

1. **创建新表**
   - 执行 `task_plans` 表创建脚本
   - 执行 `plan_progress` 表创建脚本
   - 更新 `memory_store` 表结构

2. **更新 SharedMemoryManager.setupCustomTables()**
   ```typescript
   private async setupCustomTables(): Promise<void> {
     const client = await this.pool.connect();
     try {
       // 创建 task_plans 表
       await client.query(`
         CREATE TABLE IF NOT EXISTS task_plans (
           -- 表结构如上所示
         );
       `);
       
       // 创建 plan_progress 表
       await client.query(`
         CREATE TABLE IF NOT EXISTS plan_progress (
           -- 表结构如上所示
         );
       `);
       
       // 更新 memory_store 表
       await client.query(`
         ALTER TABLE memory_store 
         ADD COLUMN IF NOT EXISTS data_type VARCHAR(50),
         ADD COLUMN IF NOT EXISTS tags JSONB;
       `);
       
       // 创建索引
       await client.query(`
         -- 所有索引创建语句
       `);
     } finally {
       client.release();
     }
   }
   ```

### 7.2 第二阶段：扩展 SharedMemoryManager

1. **添加新的接口和方法**
   - 实现 TaskPlan 相关方法
   - 实现 PlanProgress 相关方法
   - 实现统计和查询方法

2. **向后兼容性**
   - 保持现有方法不变
   - 新方法使用新的表结构
   - 提供迁移工具

### 7.3 第三阶段：改造 PostgreSQLStore

1. **实现 batch 方法**
2. **添加复杂查询功能**
3. **添加批量操作支持**
4. **性能优化**

### 7.4 第四阶段：集成测试

1. **单元测试**
   - 测试新增的所有方法
   - 测试数据一致性
   - 测试事务处理

2. **集成测试**
   - 测试 PlanAgent 和 TestAgent 的集成
   - 测试并发访问
   - 测试性能

3. **迁移测试**
   - 测试现有数据的兼容性
   - 测试升级过程

### 7.5 第五阶段：部署和监控

1. **渐进式部署**
   - 先部署数据库变更
   - 再部署应用代码
   - 监控系统性能

2. **监控指标**
   - 数据库查询性能
   - 内存使用情况
   - 任务执行成功率
   - 系统响应时间

## 8. 性能优化建议

### 8.1 数据库优化

1. **索引策略**
   - 为常用查询字段创建复合索引
   - 定期分析查询计划
   - 使用部分索引优化特定查询

2. **分区策略**
   ```sql
   -- 按时间分区 task_plans 表
   CREATE TABLE task_plans_2024 PARTITION OF task_plans
   FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
   ```

3. **连接池优化**
   - 调整连接池大小
   - 设置合适的超时时间
   - 监控连接使用情况

### 8.2 应用层优化

1. **缓存策略**
   - 对频繁访问的进度信息使用内存缓存
   - 实现缓存失效机制
   - 使用 Redis 作为分布式缓存

2. **批量操作优化**
   - 使用事务批量插入
   - 实现批量更新
   - 优化大数据量查询

## 9. 监控和日志

### 9.1 监控指标

1. **业务指标**
   - 任务执行成功率
   - 平均任务执行时间
   - 批次完成率
   - 计划进度统计

2. **技术指标**
   - 数据库连接数
   - 查询响应时间
   - 内存使用率
   - CPU 使用率

### 9.2 日志策略

1. **结构化日志**
   ```typescript
   // 示例日志格式
   {
     "timestamp": "2024-01-15T10:30:00Z",
     "level": "info",
     "component": "SharedMemoryManager",
     "operation": "saveTaskPlan",
     "planId": "plan-123",
     "taskId": "task-456",
     "duration": 150,
     "success": true
   }
   ```

2. **错误追踪**
   - 记录详细的错误信息
   - 包含上下文信息
   - 支持错误聚合和分析

## 10. 总结

本技术文档提供了完整的记忆系统改造方案，主要改进包括：

1. **数据模型优化**：设计了专门的 `task_plans` 和 `plan_progress` 表
2. **功能扩展**：为 SharedMemoryManager 添加了专门的业务方法
3. **性能提升**：实现了批量操作和复杂查询功能
4. **集成方案**：提供了与 PlanAgent 和 TestAgent 的集成示例
5. **实施策略**：制定了详细的分阶段实施计划

通过这些改造，记忆系统将能够更好地支持 PlanAgent 的迭代执行需求，提供高效的任务管理和进度跟踪功能。